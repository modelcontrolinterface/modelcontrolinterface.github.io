---
title: "MCIR CLI Tool"
---

The **MCIR CLI** is a minimal command-line tool designed to publish artifacts into one or more **MCI registries**. It occupies the same conceptual space as tools like `npm publish` or container registry CLIs, but for **MCI
specifications** and **MCI modules**.

MCIR is deliberately narrow in scope. It reads local metadata, resolves referenced files, authenticates against configured registries, and submits publish requests. It is not a build system, a semantic validator, or a registry browser. It is a transport mechanism.

## Goals and Non-Goals

### Goals

- Provide a simple, deterministic workflow for publishing MCI artifacts
- Require minimal configuration and minimal commands
- Be automation-friendly (CI/CD, scripts)
- Fail loudly and transparently on configuration or registry errors

### Non-Goals

- Acting as a general registry client (search, fetch, etc.)
- Managing versions beyond what a registry enforces
- Deep semantic validation beyond basic structure
- Editing, generating, or interpreting specifications

## Core Concepts

### Artifact Types

MCIR supports **two publishable artifact types**:

- **Modules**
- **Specifications**

Both artifact types share the same high-level publish flow, but differ in manifest shape and referenced files.

Intent is explicit at the CLI level. MCIR does not infer artifact type from directory structure.

```
mcir module push
mcir spec push
```

All commands operate on the **current working directory**. No path arguments are accepted.

## Artifact Manifests

MCIR uses TOML _artifact manifest_ files to declare publishable artifacts. These files are always local to the artifact being published and are distinct from the MCIR CLI configuration.

Only a minimal set of fields is globally required. All other metadata is treated as extensible and passed through to registries.

Paths declared in artifact manifests are resolved relative to the directory containing the manifest file. Only **relative paths** are permitted; resolution outside the working directory is explicitly forbidden.

d

### Common Metadata and Extensibility

MCIR treats artifact manifests as **open documents**. Beyond required fields, manifests may contain arbitrary metadata.

To make extensibility explicit and predictable, MCIR defines two extension mechanisms:

### `extras`

`extras` is a free-form table for **registry-agnostic metadata**. It is the canonical home for fields such as:

- Versions
- Descriptions
- Authors
- Keywords
- Licensing metadata
- Project URLs
- Any other non-standardized fields

MCIR does not interpret or validate the contents of `extras`. The table is passed verbatim to all target registries.

### `keyed-extras`

`keyed-extras` is a map of registry identifiers to per-registry metadata tables.

This mechanism allows registry-specific fields without polluting the global namespace or creating conflicts between registries.

Only the registry matching the key receives the corresponding extras table. All other registries ignore it.

MCIR enforces that fields standardized at the global level **must not** be duplicated inside `extras` or `keyed-extras`.

### Module Manifest (`module.toml`)

### Required Fields (Global)

- `id` (string): Globally unique identifier

### Optional Fields (Global)

- `type` (string): Module category (e.g. `server`)
- `wasm` (string, path): Output WASM artifact
- `build` (string): Build command to execute
- `registries` (array): Target registry identifiers

All additional metadata **must** live in `extras` or `keyed-extras`.

### Specification Manifest (`specification.toml`)

### Required Fields (Global)

- `id` (string): Globally unique identifier

### Optional Fields (Global)

- `type` (string): Specification kind (e.g. `openapi`)
- `spec_path` (string, path): Primary specification document
- `registries` (array): Target registry identifiers

All additional metadata **must** live in `extras` or `keyed-extras`.

### Example Artifact Manifest

```toml
id = "mci.example.greeter"
type = "module"
wasm = "./build/greeter.wasm"
registries = ["MMCIR", "ALTREG"]

[extras]
version = "1.2.0"
description = "A minimal greeting module"
authors = ["Example Org"]
license = "MIT"
homepage = "https://example.org/greeter"

[keyed-extras.MMCIR]
compatibility = "mci-1.0"
review-notes = "Verified against reference runtime"

[keyed-extras.ALTREG]
tier = "experimental"
```

This example demonstrates:

- Globally required fields at the top level
- Registry-agnostic metadata in `extras`
- Registry-specific metadata isolated in `keyed-extras`

## MCIR CLI Tool Configuration and Usage

### CLI Configuration File

MCIR uses a separate **CLI configuration file** to store registry endpoints and authentication information. This file is global to the tool and independent of any artifact.

Users may point MCIR to this file using the `MCIR_CONFIG_PATH` environment variable.

Example `mcir_config.toml`:

```toml
[registries.MMCIR]
url = "https://modules.mci.io/api/publish"
token = "<optional-token>"
```

Each registry entry has a user-defined identifier and includes:

- `url`: Full publish endpoint
- `token` (optional): API token stored locally (not recommended for CI)

### Authentication and Login Command

`mcir login` configures registry entries in the CLI configuration file. It supports both interactive and flag-based usage.

Flags:

- `-registry-id` (required if not already configured)
- `-url` (required if not already configured)
- `-token` (optional; stored insecurely)

Behavior:

1. Flags override existing configuration
2. If no token is provided, MCIR attempts to resolve it from `MCIR_TOKEN_<REGISTRY_ID>`
3. If no token is found, publish operations fail immediately

This hybrid model supports local development and CI usage without ambiguity.

## CLI Interface

### Explicit Artifact Namespace

Artifact type is encoded directly into the command namespace. This ensures explicit intent and simplifies testing.

```
mcir login
mcir module push
mcir spec push
```

### Publish Flow

 1. Resolve working directory
 2. Load and parse artifact manifest
 3. Validate required global fields
 4. Resolve referenced file paths (restricted to working directory)
 5. Merge registry-specific extras
 6. Construct POST payload (JSON + files)
 7. Attach authentication credentials
 8. POST payload to each configured registry
 9. Continue publishing if some registries fail
10. Report successes and failures

### Error Handling

- Exit code `0`: all publishes succeeded
- Exit code `1`: one or more publishes failed

Local errors (invalid TOML, missing files, path violations) abort immediately. Remote errors are reported per registry.

## Testing (Planned)

- No retries or automatic recovery
- Deterministic behavior suitable for CI
- Clear separation between local and remote failure modes

## Future Extensions (Out of Scope)

MCIR is intentionally boring. It validates presence, not meaning. Complexity belongs in registries and artifacts, not the transport layer.

Planned but out-of-scope features include:

- Multi-artifact batch publishing
- Local linting or validation
- Registry discovery commands
- Dry-run publishing

The guiding rule is restraint: MCIR will do less, reliably.