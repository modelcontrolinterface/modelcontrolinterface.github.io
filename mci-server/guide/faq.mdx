---
title: "Frequently Asked Questions"
description: "Frequent questions about MCI"
---

Modern AI systems are increasingly expected to act in the real world-modifying
databases, deploying code, controlling hardware, and coordinating with other
software agents.
While large language models (LLMs) excel at reasoning and synthesis, they are
non-deterministic by nature and were never designed to function as trusted
execution engines.

Most current integration strategies attempt to bridge this gap by extending the
model's **context**. These systems describe external tools and APIs to the
model, then rely on the model to invoke them correctly and safely.
While this works for experimentation, it begins to fail as soon as systems
require reliability, security, cost predictability, or long-term autonomy.

## MCP in Context

The Model Context Protocol (MCP) is the standard-bearer for this
context-extension approach. It standardizes how tools and services are described
to a model and how models issue structured requests back to those services.

This design offers clear benefits:

- **Low initial setup cost:** Easy for developers to implement quickly.
- **A unified protocol:** Reduces the need for custom "glue code."
- **Ecosystem momentum:** Strong early adoption and community interest.

For lightweight, low-risk integrations, MCP is often sufficient. However, MCP’s
core assumption-that exposing capabilities through context is a reliable control
surface—becomes increasingly fragile as systems scale.

## Where Context-Based Control Breaks Down

Relying on context as the primary mechanism for action introduces several
systemic constraints:

- **Security:** Safety depends on the model interpreting instructions correctly
  rather than on strictly enforced boundaries.
- **Cost:** Expenses scale with complexity due to "token inflation" as more
  tools are described in the prompt.
- **Reliability:** Systems are limited by non-deterministic behavior and
  late-stage error detection.
- **State:** Memory is ephemeral and session-bound, making it prone to
  "hallucinated" history or context loss.
- **Latency:** Performance degrades as serialized, blocking requests accumulate.

These are not mere implementation bugs; they are the natural consequences of
using a probabilistic reasoning system as an execution coordinator.

## The MCI Reframing

The Model Control Interface (MCI) takes a different position:

> **Models are excellent at deciding *what* should be done, but they should not
be responsible for *doing* it.**

MCI introduces a control-oriented architecture that places deterministic
systems between model intent and real-world effects.
Instead of emitting simple tool calls, models emit **executable code** that
runs inside a secure, sandboxed runtime managed by MCI.

## What MCI Enables

By separating reasoning from execution, MCI enables capabilities that are
difficult or impractical under context‑based protocols:

- **Deterministic Security:** Achieved through sandboxing, strict permissions,
  and secret isolation.
- **Long-Running Workflows:** Supports asynchronous tasks without bloating the
  model’s context.
- **Action Chaining:** Complex tasks are expressed as full programs rather than
  a series of fragmented, serialized requests.
- **Persistent State:** State is managed explicitly outside the model, ensuring
  continuity.
- **Passive Context:** Event-driven hooks allow the system to respond to
  changes without constant polling.
- **Deep Observability:** Structured logging and interceptors allow for total
  visibility into every action.

These properties make MCI the superior choice for robotics, infrastructure
automation, security monitoring, and multi-agent collaboration.

## A Concrete Example: Code Maintenance

Imagine an autonomous agent tasked with repository maintenance.

- **The Context-Based Approach (MCP):** Each step—reading files, running tests,
  applying patches, and committing changes—must be individually described to,
  and invoked by, the model. Errors surface late, costs rise with every turn,
  and recovery from a failed test is difficult.
- **The MCI Approach:** The model emits a single, cohesive script. This script
  reads the repository, runs the test suite, applies fixes, validates the
  results, and pushes the changes—all within a controlled environment.
  The model oversees the process, but the MCI runtime handles the
  "heavy lifting" deterministically.

## When to Choose MCI

MCI is designed for any system that requires high stakes and high reliability.
It is particularly well-suited for:

* Strong security and "Human-in-the-loop" requirements.
* Predictable and optimized operational costs.
* Complex, multi-step, or background execution.
* Integration with a wide array of heterogeneous services.
* Strict audit trails and failure recovery.

## Frequently Asked Questions (FAQs)

<AccordionGroup>
  <Accordion title="What is MCI actually providing?" icon="message-circle-question-mark">
    MCI is an open-source, **protocol-agnostic** system.
    Clients connect to an MCI server, which then handles all communication and
    execution logic with end services. It acts as the "operating system" for
    model-driven actions.
  </Accordion>

  <Accordion title="What does the “code” look like?" icon="message-circle-question-mark">
    MCI doesn't force a proprietary language (DSL) on you. It uses
    **language modules** that translate specifications into standard libraries.

    This means models can write tasks in Python, JavaScript, or any language the
    runtime supports.
  </Accordion>

  <Accordion title="What makes MCI more secure and observable?" icon="message-circle-question-mark">
    MCI utilizes **interceptor modules** that function like middleware.
    These modules can inspect every dispatch made by the code to block,
    redirect, or log actions. For example, a Permissions Interceptor can
    cross-reference an action against a security policy before execution.
  </Accordion>

  <Accordion title="Is MCI execution stateful?" icon="message-circle-question-mark">
    Yes. While MCP relies on the model’s limited context window to "remember"
    state, MCI shifts state management to the code and the runtime. This keeps
    the model's context clear and makes tool interactions significantly more
    reliable.
  </Accordion>

  <Accordion title="How does MCI interact with the existing MCP ecosystem?" icon="message-circle-question-mark">
    MCI is designed to complement, not replace, MCP. To MCI, MCP is simply
    another protocol standard, much like REST or JSON-RPC. An MCI server can act
    as a bridge to existing MCP servers, giving you the best of both worlds.
  </Accordion>

  <Accordion title="Is MCI trying to replace tool calling?" icon="message-circle-question-mark">
    Not at all. MCI still utilizes tool calls, but it enables
    **multi-step, stateful** execution. Instead of the model performing one tool
    call at a time in a "chat" loop, it can chain and parallelize multiple calls
    within a single execution block.
  </Accordion>

  <Accordion title="Why not just extend MCP to do this?" icon="message-circle-question-mark">
    MCP is a communication standard. Incorporating these features would require
    redefining its core principles, likely breaking existing implementations.
    While third-party wrappers could add *some* of this functionality to MCP,
    they cannot match the native security and efficiency of a purpose-built
    control interface.
  </Accordion>

  <Accordion title="Is MCI opinionated about hosting or deployment?" icon="message-circle-question-mark">
    No. MCI is infrastructure-neutral. Whether you are running on-prem, in the
    cloud, or on embedded devices, MCI is compatible as long as the host
    environment can enforce the execution contract.
  </Accordion>
</AccordionGroup>
